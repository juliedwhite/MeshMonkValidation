---
title: "Analysis for MeshMonk Validation"
author: "Julie D. White"
date: "Begun May 26, 2018"
date: "Revision completed February 20, 2019"
output: html_document
---
#Packages and functions
```{r}
library(readxl)
library(ggplot2)
library(reshape2)
library(plyr)
library(car)
library(ICC)
library(BlandAltmanLeh)
library(geomorph)
library(GGally)
library(data.table)
library(dplyr)
library(broom)
library(ggpubr)
```
Root mean squared error and euclidean distance
```{r}
RMSE = function(fitted, observed){sqrt(mean((fitted - observed)^2))}
EuclideanDistance <- function(x1,x2,y1,y2,z1,z2){sqrt(sum((x1-x2)^2+(y1-y2)^2+(z1-z2)^2))}
```
#The dataset
Individuals and their landmarks are rows, then the different landmarkings and statistics in columns. 
```{r}
landmarks <- read_excel("SparseLandmarkingManualAndAutomaticv20180226LOO.xlsx", sheet = "Combined")
head(landmarks)
```
All the columns with "ml" are the manual landmarks placed by observer A and B. Three iterations by two raters = six total landmark placements

A_surf_avg landmarks are the result of PC averaging together observer A's three iterations and then placing them on the facial surface. B_surf_avg landmarks are the result of PC averaging together observer B's three iterations and then placing them on the facial surface. C_surf_avg landmarks are the result of PC averaging together all six iterations and then placing them on the facial surface.

_loo landmarks are the result of PC using the surf_avg landmarks on all faces to "train" the placement for that landmark and then place them on each face, done 41 times, but each face's landmarks are left out ititeratively in the training. 

#Intra-observer error of only manual landmarks
Create dataframe for intra observer error of manual landmarks
```{r}
ML_Intra <- landmarks[,c("ID", "LM.Num", "LM.Name")]
```
##Observer A
Calculate the sdandard deviations across iterations for x, y, z
```{r}
ML_Intra$A_ml_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_ml_x1", "A_ml_x2", "A_ml_x3")])) 
ML_Intra$A_ml_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_ml_y1", "A_ml_y2", "A_ml_y3")]))
ML_Intra$A_ml_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_ml_z1", "A_ml_z2", "A_ml_z3")]))
```
Average of A's sd x, sd y, sd z across all landmarks
```{r}
mean(ML_Intra$A_ml_sdx)
mean(ML_Intra$A_ml_sdy)
mean(ML_Intra$A_ml_sdz)
```
Standard deviation of A's sd x, y, and z across all landmarks
```{r}
sd(ML_Intra$A_ml_sdx)
sd(ML_Intra$A_ml_sdy)
sd(ML_Intra$A_ml_sdz)
```

Boxplot of A's sd x, y, z
```{r}
ggplot(data = melt(ML_Intra[, c("ID", "LM.Num", "LM.Name", "A_ml_sdx", "A_ml_sdy", "A_ml_sdz")], id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_minimal()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "right", legend.title = element_blank())+scale_fill_discrete(breaks=c("A_ml_sdx", "A_ml_sdy", "A_ml_sdz"), labels=c("X", "Y", "Z"))+ylab("Standard Deviation (mm)")+xlab("Landmark")+ggtitle("Standard deviation of x, y, and z coordinates for observer A")
```

##Rater B
Calculate the sdandard deviations across iterations for x, y, z
```{r}
ML_Intra$B_ml_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("B_ml_x1", "B_ml_x2", "B_ml_x3")])) 
ML_Intra$B_ml_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("B_ml_y1", "B_ml_y2", "B_ml_y3")]))
ML_Intra$B_ml_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("B_ml_z1", "B_ml_z2", "B_ml_z3")]))
```
Average of observer B's sd x, y, z across all landmarks
```{r}
mean(ML_Intra$B_ml_sdx)
mean(ML_Intra$B_ml_sdy)
mean(ML_Intra$B_ml_sdz)
```
Standard deviation of observer B's sd x, y, and z across all landmarks
```{r}
sd(ML_Intra$B_ml_sdx)
sd(ML_Intra$B_ml_sdy)
sd(ML_Intra$B_ml_sdz)
```
Boxplot of observer B's sd x, y, z 
```{r}
ggplot(data = melt(ML_Intra[, c("ID", "LM.Num", "LM.Name", "B_ml_sdx", "B_ml_sdy", "B_ml_sdz")], id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_minimal()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "right", legend.title = element_blank())+scale_fill_discrete(breaks=c("B_ml_sdx", "B_ml_sdy", "B_ml_sdz"), labels=c("X", "Y", "Z"))+ylab("Standard Deviation (mm)")+xlab("Landmark")+ggtitle("Standard deviation of x, y, and z coordinates for observer B")
```
##Average SD per landmark
```{r}
ML_IntraByLandmark <- ddply(ML_Intra,~LM.Name,summarise, A_ml_sdx = mean(A_ml_sdx), A_ml_sdy = mean(A_ml_sdy), A_ml_sdz = mean(A_ml_sdz), B_ml_sdx = mean(B_ml_sdx), B_ml_sdy = mean(B_ml_sdy), B_ml_sdz = mean(B_ml_sdz))

write.table(ML_IntraByLandmark, "Tables/ML_IntraByLandmark.txt", row.names = F, col.names = T, quote = F, sep = "\t")

ML_IntraByLandmark
```

#Inter-observer error of only manual landmarks (sd)
##Averaged across landmarks and images
```{r}
ML_Inter <- landmarks[,c("ID", "LM.Num", "LM.Name")]
```
This calculation will be performed on the average of each rater's landmarks, since the intra-observer error was low.
Average of A's x y and z 
```{r}
landmarks$A_ml_avgx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_x1", "A_ml_x2", "A_ml_x3")])) 
landmarks$A_ml_avgy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_y1", "A_ml_y2", "A_ml_y3")]))
landmarks$A_ml_avgz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_z1", "A_ml_z2", "A_ml_z3")]))
```
Avearge of B's x y and z 
```{r}
landmarks$B_ml_avgx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("B_ml_x1", "B_ml_x2", "B_ml_x3")])) 
landmarks$B_ml_avgy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("B_ml_y1", "B_ml_y2", "B_ml_y3")]))
landmarks$B_ml_avgz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("B_ml_z1", "B_ml_z2", "B_ml_z3")]))
```
Calculate the sd from A's avg x, y, and z values and B's x, y, and z values.
```{r}
ML_Inter$Aml_Bml_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x["A_ml_avgx"], x["B_ml_avgx"]))) 
ML_Inter$Aml_Bml_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x["A_ml_avgy"], x["B_ml_avgy"])))
ML_Inter$Aml_Bml_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x["A_ml_avgz"], x["B_ml_avgz"])))

#Average
ML_Inter$Aml_Bml_avg_sd <- rowMeans(subset(ML_Inter, select = c(Aml_Bml_sdx, Aml_Bml_sdy, Aml_Bml_sdz)))
```
Average of sd x, y, z across all landmarks
```{r}
mean(ML_Inter$Aml_Bml_sdx)
mean(ML_Inter$Aml_Bml_sdy)
mean(ML_Inter$Aml_Bml_sdz)
```
Boxplot of sd x, y, z
```{r}
ggplot(data = melt(ML_Inter[, c("ID", "LM.Num", "LM.Name", "Aml_Bml_sdx", "Aml_Bml_sdy", "Aml_Bml_sdz")], id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_minimal()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "right", legend.title = element_blank())+scale_fill_discrete(breaks=c("Aml_Bml_sdx", "Aml_Bml_sdy", "Aml_Bml_sdz"), labels=c("X", "Y", "Z"))+ylab("Standard deviation (mm)")+xlab("Landmark")+ggtitle("Inter-observer error")
```
One high sdx value for chelion left
```{r}
ML_Inter[which(ML_Inter$Aml_Bml_sdx == max(ML_Inter$Aml_Bml_sdx)),]
```
 
##Average per landmark 
```{r}
ML_InterByLandmark <- ddply(ML_Inter,~LM.Name,summarise, Aml_Bml_sdx = mean(Aml_Bml_sdx), Aml_Bml_sdy = mean(Aml_Bml_sdy), Aml_Bml_sdz = mean(Aml_Bml_sdz), Aml_Bml_avg_sd = mean(Aml_Bml_avg_sd)) 

write.table(ML_InterByLandmark, "Tables/ML_InterByLandmarks.txt", row.names = F, col.names = T, quote = F, sep = "\t")

ML_InterByLandmark
```

#Correlation between manual and automatic landmarks
Create the average of A's landmarks as well as B's landmarks to directly compare to the automatic landmarks. 
```{r}
landmarks$C_ml_avgx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_x1", "A_ml_x2", "A_ml_x3", "B_ml_x1", "B_ml_x2", "B_ml_x3")])) 
landmarks$C_ml_avgy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_y1", "A_ml_y2", "A_ml_y3", "B_ml_y1", "B_ml_y2", "B_ml_y3")]))
landmarks$C_ml_avgz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_z1", "A_ml_z2", "A_ml_z3", "B_ml_z1", "B_ml_z2", "B_ml_z3")]))
```
Intraclass correlation coefficient between manual and automatic landmarks
```{r}
#A's data 
ICCmelt <- melt(landmarks[c("ID", "LM.Name","A_ml_avgx", "A_loo_x")], id.vars = c("ID", "LM.Name"))
ICCmelt$group <- apply(ICCmelt[, c("ID", "LM.Name")], 1, paste, collapse = "-")
ICC_Ax <- ICCest(x=group, y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

ICCmelt <- melt(landmarks[c("ID", "LM.Name","A_ml_avgy", "A_loo_y")], id.vars = c("ID", "LM.Name"))
ICCmelt$group <- apply(ICCmelt[, c("ID", "LM.Name")], 1, paste, collapse = "-")
ICC_Ay <- ICCest(x=group, y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

ICCmelt <- melt(landmarks[c("ID", "LM.Name","A_ml_avgz", "A_loo_z")], id.vars = c("ID", "LM.Name"))
ICCmelt$group <- apply(ICCmelt[, c("ID", "LM.Name")], 1, paste, collapse = "-")
ICC_Az <- ICCest(x=group, y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

#B's data
ICCmelt <- melt(landmarks[c("ID", "LM.Name","B_ml_avgx", "B_loo_x")], id.vars = c("ID", "LM.Name"))
ICCmelt$group <- apply(ICCmelt[, c("ID", "LM.Name")], 1, paste, collapse = "-")
ICC_Bx <- ICCest(x=group, y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

ICCmelt <- melt(landmarks[c("ID", "LM.Name","B_ml_avgy", "B_loo_y")], id.vars = c("ID", "LM.Name"))
ICCmelt$group <- apply(ICCmelt[, c("ID", "LM.Name")], 1, paste, collapse = "-")
ICC_By <- ICCest(x=group, y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

ICCmelt <- melt(landmarks[c("ID", "LM.Name","B_ml_avgz", "B_loo_z")], id.vars = c("ID", "LM.Name"))
ICCmelt$group <- apply(ICCmelt[, c("ID", "LM.Name")], 1, paste, collapse = "-")
ICC_Bz <- ICCest(x=group, y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

#Combined (C)
ICCmelt <- melt(landmarks[c("ID", "LM.Name","C_ml_avgx", "C_loo_x")], id.vars = c("ID", "LM.Name"))
ICCmelt$group <- apply(ICCmelt[, c("ID", "LM.Name")], 1, paste, collapse = "-")
ICC_Cx <- ICCest(x=group, y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

ICCmelt <- melt(landmarks[c("ID", "LM.Name","C_ml_avgy", "C_loo_y")], id.vars = c("ID", "LM.Name"))
ICCmelt$group <- apply(ICCmelt[, c("ID", "LM.Name")], 1, paste, collapse = "-")
ICC_Cy <- ICCest(x=group, y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

ICCmelt <- melt(landmarks[c("ID", "LM.Name","C_ml_avgz", "C_loo_z")], id.vars = c("ID", "LM.Name"))
ICCmelt$group <- apply(ICCmelt[, c("ID", "LM.Name")], 1, paste, collapse = "-")
ICC_Cz <- ICCest(x=group, y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")
```
Pearson's correlation between manual landmarks and automatic landmarks
```{r}
cor(landmarks$C_ml_avgx, landmarks$C_loo_x, method = "pearson")
cor(landmarks$C_ml_avgy, landmarks$C_loo_y, method = "pearson")
cor(landmarks$C_ml_avgz, landmarks$C_loo_z, method = "pearson")
```
Plot these correlations
```{r}
Corr_Cml_Cloo_x <- ggplot(landmarks, aes(C_ml_avgx, C_loo_x))+geom_point(size=0.5)+theme_bw()+labs(title = "X", subtitle="ICC = 0.999523\n95% CI = [0.999456, 0.999590]", x="", y="Automatic landmark coordinates")
Corr_Cml_Cloo_y <- ggplot(landmarks, aes(C_ml_avgy, C_loo_y))+geom_point(size=0.5)+theme_bw()+labs(title = "Y", subtitle="ICC = 0.999757\n95% CI = [0.999723, 0.999792]", x="Manual landmark coordinates", y=NULL)
Corr_Cml_Cloo_z <- ggplot(landmarks, aes(C_ml_avgz, C_loo_z))+geom_point(size=0.5)+theme_bw()+labs(title = "Z", subtitle="ICC = 0.999921\n95% CI = [0.999910, 0.999932]", x="", y=NULL)

ggarrange(Corr_Cml_Cloo_x, Corr_Cml_Cloo_y, Corr_Cml_Cloo_z, ncol = 3)
```

Bland Altman Plot
```{r}
#X
ba_Cx <- bland.altman.stats(landmarks$C_ml_avgx, landmarks$C_loo_x)
ba_Cx_df <- as.data.frame(matrix(c(landmarks$ID, landmarks$LM.Name), nrow = 779))
ba_Cx_df$means <- ba_Cx$means
ba_Cx_df$diffs <- ba_Cx$diffs

ba_Cx_plot <- ggplot(ba_Cx_df, aes(x=means, y=diffs))+geom_point(size = 0.5, alpha = 0.5)+ylim(-5,6)+theme_bw()+labs(title = "X",subtitle="ICC = 0.999523\n95% CI = [0.999456, 0.999590]", x="", y="Differences (mm)")+theme(plot.subtitle=element_text(size=8))+geom_hline(yintercept = ba_Cx$lines['lower.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_Cx$lines['mean.diffs'], linetype = "solid", color = "blue")+geom_hline(yintercept = ba_Cx$lines['upper.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_Cx$CI.lines['lower.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_Cx$CI.lines['lower.limit.ci.upper'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_Cx$CI.lines['mean.diff.ci.lower'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_Cx$CI.lines['mean.diff.ci.upper'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_Cx$CI.lines['upper.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_Cx$CI.lines['upper.limit.ci.upper'], linetype = "dashed", color = "red")

#Y
ba_Cy <- bland.altman.stats(landmarks$C_ml_avgy, landmarks$C_loo_y)
ba_Cy_df <- as.data.frame(matrix(c(landmarks$ID, landmarks$LM.Name), nrow = 779))
ba_Cy_df$means <- ba_Cy$means
ba_Cy_df$diffs <- ba_Cy$diffs

ba_Cy_plot <- ggplot(ba_Cy_df, aes(x=means, y=diffs))+geom_point(size = 0.5, alpha = 0.5)+ylim(-5,6)+theme_bw()+labs(title = "Y", subtitle="ICC = 0.999757\n95% CI = [0.999723, 0.999792]", x="Means (mm)", y="")+theme(plot.subtitle=element_text(size=8))+geom_hline(yintercept = ba_Cy$lines['lower.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_Cy$lines['mean.diffs'], linetype = "solid", color = "blue")+geom_hline(yintercept = ba_Cy$lines['upper.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_Cy$CI.lines['lower.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_Cy$CI.lines['lower.limit.ci.upper'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_Cy$CI.lines['mean.diff.ci.lower'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_Cy$CI.lines['mean.diff.ci.upper'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_Cy$CI.lines['upper.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_Cy$CI.lines['upper.limit.ci.upper'], linetype = "dashed", color = "red")

#Z
ba_Cz <- bland.altman.stats(landmarks$C_ml_avgz, landmarks$C_loo_z)
ba_Cz_df <- as.data.frame(matrix(c(landmarks$ID, landmarks$LM.Name), nrow = 779))
ba_Cz_df$means <- ba_Cz$means
ba_Cz_df$diffs <- ba_Cz$diffs

ba_Cz_plot <- ggplot(ba_Cz_df, aes(x=means, y=diffs))+geom_point(size = 0.5, alpha = 0.5)+ylim(-5,6)+theme_bw()+labs(title = "Z", subtitle="ICC = 0.999921\n95% CI = [0.999910, 0.999932]", x="", y="")+theme(plot.subtitle=element_text(size=8))+geom_hline(yintercept = ba_Cz$lines['lower.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_Cz$lines['mean.diffs'], linetype = "solid", color = "blue")+geom_hline(yintercept = ba_Cz$lines['upper.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_Cz$CI.lines['lower.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_Cz$CI.lines['lower.limit.ci.upper'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_Cz$CI.lines['mean.diff.ci.lower'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_Cz$CI.lines['mean.diff.ci.upper'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_Cz$CI.lines['upper.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_Cz$CI.lines['upper.limit.ci.upper'], linetype = "dashed", color = "red")

ggarrange(ba_Cx_plot, ba_Cy_plot, ba_Cz_plot, ncol = 3)
```

#Comparison of raw manual and automatic landmark values
##RMSE between manual landmarks and auto landmarks 
Create a dataframe to store the results of the comparisons
```{r}
MLvsAuto_RMSE <- landmarks[,c("ID", "LM.Num", "LM.Name")]
``` 
RMSE between the ML and auto landmarks
```{r}
#A manual to A auto
MLvsAuto_RMSE$Aml_Aloo_rmsex <- apply(landmarks[4:ncol(landmarks)], 1, function(x) RMSE(x['A_loo_x'], x['A_ml_avgx']))
MLvsAuto_RMSE$Aml_Aloo_rmsey <- apply(landmarks[4:ncol(landmarks)], 1, function(x) RMSE(x['A_loo_y'], x['A_ml_avgy']))
MLvsAuto_RMSE$Aml_Aloo_rmsez <- apply(landmarks[4:ncol(landmarks)], 1, function(x) RMSE(x['A_loo_z'], x['A_ml_avgz']))
MLvsAuto_RMSE$Aml_Aloo_avg_rmse <- rowMeans(subset(MLvsAuto_RMSE, select = c(Aml_Aloo_rmsex, Aml_Aloo_rmsey, Aml_Aloo_rmsez)))

#B manual to B auto
MLvsAuto_RMSE$Bml_Bloo_rmsex <- apply(landmarks[4:ncol(landmarks)], 1, function(x) RMSE(x['B_loo_x'], x['B_ml_avgx']))
MLvsAuto_RMSE$Bml_Bloo_rmsey <- apply(landmarks[4:ncol(landmarks)], 1, function(x) RMSE(x['B_loo_y'], x['B_ml_avgy']))
MLvsAuto_RMSE$Bml_Bloo_rmsez <- apply(landmarks[4:ncol(landmarks)], 1, function(x) RMSE(x['B_loo_z'], x['B_ml_avgz']))
MLvsAuto_RMSE$Bml_Bloo_avg_rmse <- rowMeans(subset(MLvsAuto_RMSE, select = c(Bml_Bloo_rmsex, Bml_Bloo_rmsey, Bml_Bloo_rmsez)))

#C manual to C auto
MLvsAuto_RMSE$Cml_Cloo_rmsex <- apply(landmarks[4:ncol(landmarks)], 1, function(x) RMSE(x['C_loo_x'], x['C_ml_avgx']))
MLvsAuto_RMSE$Cml_Cloo_rmsey <- apply(landmarks[4:ncol(landmarks)], 1, function(x) RMSE(x['C_loo_y'], x['C_ml_avgy']))
MLvsAuto_RMSE$Cml_Cloo_rmsez <- apply(landmarks[4:ncol(landmarks)], 1, function(x) RMSE(x['C_loo_z'], x['C_ml_avgz']))
MLvsAuto_RMSE$Cml_Cloo_avg_rmse <- rowMeans(subset(MLvsAuto_RMSE, select = c(Cml_Cloo_rmsex, Cml_Cloo_rmsey, Cml_Cloo_rmsez)))
```
Write table for manuscript 
```{r}
MLvsAuto_RMSE_ByLandmark <- ddply(MLvsAuto_RMSE,~LM.Name,summarise, 
                                  Aml_Aloo_rmsex = mean(Aml_Aloo_rmsex), 
                                  Aml_Aloo_rmsey = mean(Aml_Aloo_rmsey), 
                                  Aml_Aloo_rmsez = mean(Aml_Aloo_rmsez), 
                                  Aml_Aloo_avg_rmse = mean(Aml_Aloo_avg_rmse), 
                                  Bml_Bloo_rmsex = mean(Bml_Bloo_rmsex), 
                                  Bml_Bloo_rmsey = mean(Bml_Bloo_rmsey), 
                                  Bml_Bloo_rmsez = mean(Bml_Bloo_rmsez), 
                                  Bml_Bloo_avg_rmse = mean(Bml_Bloo_avg_rmse), 
                                  Cml_Cloo_rmsex = mean(Cml_Cloo_rmsex), 
                                  Cml_Cloo_rmsey = mean(Cml_Cloo_rmsey), 
                                  Cml_Cloo_rmsez = mean(Cml_Cloo_rmsez), 
                                  Cml_Cloo_avg_rmse = mean(Cml_Cloo_avg_rmse)) 

write.table(MLvsAuto_RMSE_ByLandmark, "Tables/MLvsAuto_RMSE_PerLMK.txt", row.names = F, col.names = T, quote = F, sep = "\t")
```
Plot
```{r}
ggplot(data = melt(MLvsAuto_RMSE[, c("ID", "LM.Num", "LM.Name", "Aml_Aloo_avg_rmse","Bml_Bloo_avg_rmse", "Cml_Cloo_avg_rmse")], id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_minimal()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "top", legend.title = element_blank())+scale_fill_discrete(breaks=c("Aml_Aloo_avg_rmse", "Bml_Bloo_avg_rmse", "Cml_Cloo_avg_rmse"), labels=c("Aml - Aauto", "Bml - Bauto", "Cml - Cauto"))+ylab("Root mean squared error (mm)")+xlab("Landmark")
```

##Euclidean distance between manual landmarks and auto landmarks 
Create a dataframe to store the results of the comparisons
```{r}
MLvsAuto_Euclid <- landmarks[,c("ID", "LM.Num", "LM.Name")]
``` 
Euclid between the ML and auto landmarks
```{r}
#A manual to A auto
MLvsAuto_Euclid$Aml_Aloo_Euclid <- apply(landmarks[4:ncol(landmarks)],1,function(x) EuclideanDistance(x['A_ml_avgx'], x['A_loo_x'], x['A_ml_avgy'], x['A_loo_y'], x['A_ml_avgz'], x['A_loo_z']))

#B manual to B auto
MLvsAuto_Euclid$Bml_Bloo_Euclid <- apply(landmarks[4:ncol(landmarks)],1,function(x) EuclideanDistance(x['B_ml_avgx'], x['B_loo_x'], x['B_ml_avgy'], x['B_loo_y'], x['B_ml_avgz'], x['B_loo_z']))

#C manual to C auto
MLvsAuto_Euclid$Cml_Cloo_Euclid <- apply(landmarks[4:ncol(landmarks)],1,function(x) EuclideanDistance(x['C_ml_avgx'], x['C_loo_x'], x['C_ml_avgy'], x['C_loo_y'], x['C_ml_avgz'], x['C_loo_z']))
```
Write table for manuscript 
```{r}
MLvsAuto_Euclid_ByLandmark <- ddply(MLvsAuto_Euclid,~LM.Name,summarise,
                                    Aml_Aloo_Euclid = mean(Aml_Aloo_Euclid), 
                                    Bml_Bloo_Euclid = mean(Bml_Bloo_Euclid),
                                    Cml_Cloo_Euclid = mean(Cml_Cloo_Euclid)) 

write.table(MLvsAuto_Euclid_ByLandmark, "Tables/MLvsAuto_Euclid_PerLMK.txt", row.names = F, col.names = T, quote = F, sep = "\t")
```
Plot
```{r}
ggplot(data = melt(MLvsAuto_Euclid, id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_minimal()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "top", legend.title = element_blank())+scale_fill_discrete(labels=c("Aml - Aauto", "Bml - Bauto", "Cml - Cauto"))+ylab("Euclidean distance (mm)")+xlab("Landmark")
```

#Comparison of "inter-observer errors
Create a dataframe to store the results
```{r}
MLvsAuto_SD <- landmarks[,c("ID", "LM.Num", "LM.Name")]
```
SD between the ML landmarks and the automatic landmarks, swapping out observers
```{r}
#A manual to B auto
MLvsAuto_SD$Aml_Bloo_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['B_loo_x'], x['A_ml_avgx'])))
MLvsAuto_SD$Aml_Bloo_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['B_loo_y'], x['A_ml_avgy'])))
MLvsAuto_SD$Aml_Bloo_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['B_loo_z'], x['A_ml_avgz'])))
MLvsAuto_SD$Aml_Bloo_avg_sd <- rowMeans(subset(MLvsAuto_SD, select = c(Aml_Bloo_sdx, Aml_Bloo_sdy, Aml_Bloo_sdz)))

#A manual to C auto
MLvsAuto_SD$Aml_Cloo_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['C_loo_x'], x['A_ml_avgx'])))
MLvsAuto_SD$Aml_Cloo_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['C_loo_y'], x['A_ml_avgy'])))
MLvsAuto_SD$Aml_Cloo_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['C_loo_z'], x['A_ml_avgz'])))
MLvsAuto_SD$Aml_Cloo_avg_sd <- rowMeans(subset(MLvsAuto_SD, select = c(Aml_Cloo_sdx, Aml_Cloo_sdy, Aml_Cloo_sdz)))

#B manual to A auto
MLvsAuto_SD$Bml_Aloo_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['A_loo_x'], x['B_ml_avgx'])))
MLvsAuto_SD$Bml_Aloo_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['A_loo_y'], x['B_ml_avgy'])))
MLvsAuto_SD$Bml_Aloo_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['A_loo_z'], x['B_ml_avgz'])))
MLvsAuto_SD$Bml_Aloo_avg_sd <- rowMeans(subset(MLvsAuto_SD, select = c(Bml_Aloo_sdx, Bml_Aloo_sdy, Bml_Aloo_sdz)))

#B manual to C auto
MLvsAuto_SD$Bml_Cloo_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['C_loo_x'], x['B_ml_avgx'])))
MLvsAuto_SD$Bml_Cloo_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['C_loo_y'], x['B_ml_avgy'])))
MLvsAuto_SD$Bml_Cloo_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['C_loo_z'], x['B_ml_avgz'])))
MLvsAuto_SD$Bml_Cloo_avg_sd <- rowMeans(subset(MLvsAuto_SD, select = c(Bml_Cloo_sdx, Bml_Cloo_sdy, Bml_Cloo_sdz)))

#C manual to A auto
MLvsAuto_SD$Cml_Aloo_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['A_loo_x'], x['C_ml_avgx'])))
MLvsAuto_SD$Cml_Aloo_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['A_loo_y'], x['C_ml_avgy'])))
MLvsAuto_SD$Cml_Aloo_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['A_loo_z'], x['C_ml_avgz'])))
MLvsAuto_SD$Cml_Aloo_avg_sd <- rowMeans(subset(MLvsAuto_SD, select = c(Cml_Aloo_sdx, Cml_Aloo_sdy, Cml_Aloo_sdz)))

#C manual to B auto
MLvsAuto_SD$Cml_Bloo_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['B_loo_x'], x['C_ml_avgx'])))
MLvsAuto_SD$Cml_Bloo_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['B_loo_y'], x['C_ml_avgy'])))
MLvsAuto_SD$Cml_Bloo_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x['B_loo_z'], x['C_ml_avgz'])))
MLvsAuto_SD$Cml_Bloo_avg_sd <- rowMeans(subset(MLvsAuto_SD, select = c(Cml_Bloo_sdx, Cml_Bloo_sdy, Cml_Bloo_sdz)))

#Between A auto and B auto 
MLvsAuto_SD$Aloo_Bloo_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x["A_loo_x"], x["B_loo_x"])))
MLvsAuto_SD$Aloo_Bloo_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x["A_loo_y"], x["B_loo_y"])))
MLvsAuto_SD$Aloo_Bloo_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(c(x["A_loo_z"], x["B_loo_z"])))
MLvsAuto_SD$Aloo_Bloo_avg_sd <- rowMeans(subset(MLvsAuto_SD, select = c(Aloo_Bloo_sdx, Aloo_Bloo_sdy, Aloo_Bloo_sdz)))

#Put together the results of the manual landmarking inter-observer error and the results calculated with auto
MLvsAuto_SD$Aml_Bml_avg_sd <- ML_Inter$Aml_Bml_avg_sd
MLvsAuto_SD$Aml_Bml_sdx <- ML_Inter$Aml_Bml_sdx
MLvsAuto_SD$Aml_Bml_sdy <- ML_Inter$Aml_Bml_sdy
MLvsAuto_SD$Aml_Bml_sdz <- ML_Inter$Aml_Bml_sdz
```
Write table for manuscript 
```{r}
MLvsAuto_SD_ByLandmark <- ddply(MLvsAuto_SD,~LM.Name,summarise, 
                                  Aml_Bloo_sdx = mean(Aml_Bloo_sdx),
                                  Aml_Bloo_sdy = mean(Aml_Bloo_sdy),
                                  Aml_Bloo_sdz = mean(Aml_Bloo_sdz),
                                  Aml_Bloo_avg_sd = mean(Aml_Bloo_avg_sd),
                                  Aml_Cloo_sdx = mean(Aml_Cloo_sdx),
                                  Aml_Cloo_sdy = mean(Aml_Cloo_sdy),
                                  Aml_Cloo_sdz = mean(Aml_Cloo_sdz),
                                  Aml_Cloo_avg_sd = mean(Aml_Cloo_avg_sd),
                                  Bml_Aloo_sdx = mean(Bml_Aloo_sdx),
                                  Bml_Aloo_sdy = mean(Bml_Aloo_sdy),
                                  Bml_Aloo_sdz = mean(Bml_Aloo_sdz),
                                  Bml_Aloo_avg_sd = mean(Bml_Aloo_avg_sd),
                                  Bml_Cloo_sdx = mean(Bml_Cloo_sdx),
                                  Bml_Cloo_sdy = mean(Bml_Cloo_sdy),
                                  Bml_Cloo_sdz = mean(Bml_Cloo_sdz),
                                  Bml_Cloo_avg_sd = mean(Bml_Cloo_avg_sd),
                                  Cml_Aloo_sdx = mean(Cml_Aloo_sdx), 
                                  Cml_Aloo_sdy = mean(Cml_Aloo_sdy), 
                                  Cml_Aloo_sdz = mean(Cml_Aloo_sdz), 
                                  Cml_Aloo_avg_sd = mean(Cml_Aloo_avg_sd),
                                  Cml_Bloo_sdx = mean(Cml_Bloo_sdx), 
                                  Cml_Bloo_sdy = mean(Cml_Bloo_sdy), 
                                  Cml_Bloo_sdz = mean(Cml_Bloo_sdz), 
                                  Cml_Bloo_avg_sd = mean(Cml_Bloo_avg_sd),
                                  Aloo_Bloo_sdx = mean(Aloo_Bloo_sdx),
                                  Aloo_Bloo_sdy = mean(Aloo_Bloo_sdy),
                                  Aloo_Bloo_sdz = mean(Aloo_Bloo_sdz),
                                  Aloo_Bloo_avg_sd = mean(Aloo_Bloo_avg_sd),
                                  Aml_Bml_sdx = mean(Aml_Bml_sdx),
                                  Aml_Bml_sdy = mean(Aml_Bml_sdy),
                                  Aml_Bml_sdz = mean(Aml_Bml_sdz),
                                  Aml_Bml_avg_sd = mean(Aml_Bml_avg_sd)) 

write.table(MLvsAuto_SD_ByLandmark, "Tables/MLvsAuto_SD_PerLMK.txt", row.names = F, col.names = T, quote = F, sep = "\t")
```
##Plots
Compare:
Aml - Bml
Aml - Bauto
Aauto - Bml
Aauto - Bauto
```{r}
ggplot(data = melt(MLvsAuto_SD[, c("ID", "LM.Num", "LM.Name",  "Aml_Bml_avg_sd", "Aml_Bloo_avg_sd", "Bml_Aloo_avg_sd", "Aloo_Bloo_avg_sd")], id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_bw()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "right", legend.title = element_blank())+scale_fill_brewer(breaks=c("Aml_Bml_avg_sd", "Aml_Bloo_avg_sd", "Bml_Aloo_avg_sd", "Aloo_Bloo_avg_sd"), labels=c("Aml - Bml", "Aml - Bauto", "Aauto - Bml", "Aauto - Bauto"), palette = "Paired")+ylab("Standard deviation (mm)")+xlab("Landmark")
```

##T-test on values per landmark to see if the values of the manual landmarks are less than the values of the automatic landmarks 
```{r}
#Aml vs Bloo
AmlVsBml_AmlVsBloo_sd.Ttest = melt(MLvsAuto_SD[c("LM.Name", "Aml_Bml_avg_sd", "Aml_Bloo_avg_sd")], id.vars = "LM.Name") %>% group_by(LM.Name) %>% do(tidy(t.test(value~variable, data=., paired=TRUE)))

AmlVsBml_AmlVsBloo_sd.Ttest

write.table(AmlVsBml_AmlVsBloo_sd.Ttest, "Tables/AmlVsBml_AmlVsBauto_sd.Ttest.txt", row.names = F, col.names = T, sep = "\t", quote = F)

#Aloo vs. Bml
AmlVsBml_AlooVsBml_sd.Ttest = melt(MLvsAuto_SD[c("LM.Name", "Aml_Bml_avg_sd", "Bml_Aloo_avg_sd")], id.vars = "LM.Name") %>% group_by(LM.Name) %>% do(tidy(t.test(value~variable, data=., paired=TRUE)))

AmlVsBml_AlooVsBml_sd.Ttest

write.table(AmlVsBml_AlooVsBml_sd.Ttest, "Tables/AmlVsBml_AautoVsBml_sd.Ttest.txt", row.names = F, col.names = T, sep = "\t", quote = F)
```

##Levene's test for equal variance (used because the data do not follow a normal distribution)
See if the variances of these comparisons are equal using Levene's test
Create an array to store the results
```{r}
MLvsAuto_Levene<- array(NA, c(7, 2, 19))
dimnames(MLvsAuto_Levene)[[1]] <- c("Aml_Bloo_avg_sd", "Aml_Cloo_avg_sd", "Bml_Aloo_avg_sd", "Bml_Cloo_avg_sd", "Cml_Aloo_avg_sd", "Cml_Bloo_avg_sd", "Aloo_Bloo_avg_sd")
dimnames(MLvsAuto_Levene)[[2]] <- c("Fvalue", "Pvalue")
dimnames(MLvsAuto_Levene)[[3]] <- as.list(unique(MLvsAuto_SD$LM.Name))
```
Calculate Levene's test for each landmark and each comparison. 
```{r}
for (i in seq(1,19,1)){
  for (j in seq(1,7,1)){
    suppressMessages(levene_tmp <- leveneTest(value~variable, data=melt(MLvsAuto_SD[which(MLvsAuto_SD$LM.Name == dimnames(MLvsAuto_Levene)[[3]][i]), c("Aml_Bml_avg_sd",dimnames(MLvsAuto_Levene)[[1]][j])])))
    MLvsAuto_Levene[j,1,i] <- levene_tmp[1,2] 
    MLvsAuto_Levene[j,2,i] <- levene_tmp[1,3]
  }
}
```
Turn 3D array into 2D matrix
```{r}
dim(MLvsAuto_Levene) <- c(7,2*19)
rownames(MLvsAuto_Levene) <- c("Aml_Bloo_avg_sd", "Aml_Cloo_avg_sd", "Bml_Aloo_avg_sd", "Bml_Cloo_avg_sd", "Cml_Aloo_avg_sd", "Cml_Bloo_avg_sd", "Aloo_Bloo_avg_sd")
colnames(MLvsAuto_Levene) <- paste0(rep(unique(MLvsAuto_SD$LM.Name), each=2), rep(c("_F", "_p")))

write.table(t(MLvsAuto_Levene), "Tables/MLvsAuto_SD_Levene.txt", row.names = T, col.names = T, quote = F, sep = "\t")
```

#Read in data for Morpho analysis
##Convert manual landmarks into morpho format
###Observer A Manual landmarks
####A Iteration 1
Make empty dataframe to store landmarks
```{r}
A_MorphoData_Manual_1 <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(A_MorphoData_Manual_1) <- paste(unique(landmarks$ID), "_A_ML_1", sep = "")
colnames(A_MorphoData_Manual_1) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
A_MorphoData_ManualMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(A_MorphoData_ManualMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
A_MorphoData_ManualMap$sourcerow <- rep(seq(1,779,1), each=3) 
A_MorphoData_ManualMap$sourcecolumn <- rep(c("A_ml_x1","A_ml_y1", "A_ml_z1"), length = 2337)
A_MorphoData_ManualMap$targetrow <- rep(seq(1,41,1), each = 57)
A_MorphoData_ManualMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(A_MorphoData_ManualMap)){A_MorphoData_Manual_1[A_MorphoData_ManualMap[i,3], A_MorphoData_ManualMap[i,4]] <- landmarks[A_MorphoData_ManualMap[i,1], A_MorphoData_ManualMap[i,2]]
}

rm(i)

A_MorphoData_Manual_1 <- as.matrix(A_MorphoData_Manual_1)
```
####A Iteration 2
Make empty dataframe to store landmarks
```{r}
A_MorphoData_Manual_2 <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(A_MorphoData_Manual_2) <- paste(unique(landmarks$ID), "_A_ML_2", sep = "")
colnames(A_MorphoData_Manual_2) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
A_MorphoData_ManualMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(A_MorphoData_ManualMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
A_MorphoData_ManualMap$sourcerow <- rep(seq(1,779,1), each=3) 
A_MorphoData_ManualMap$sourcecolumn <- rep(c("A_ml_x2","A_ml_y2", "A_ml_z2"), length = 2337)
A_MorphoData_ManualMap$targetrow <- rep(seq(1,41,1), each = 57)
A_MorphoData_ManualMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(A_MorphoData_ManualMap)){A_MorphoData_Manual_2[A_MorphoData_ManualMap[i,3], A_MorphoData_ManualMap[i,4]] <- landmarks[A_MorphoData_ManualMap[i,1], A_MorphoData_ManualMap[i,2]]
}

rm(i)

A_MorphoData_Manual_2 <- as.matrix(A_MorphoData_Manual_2)
```
####A Iteration 3
Make empty dataframe to store landmarks
```{r}
A_MorphoData_Manual_3 <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(A_MorphoData_Manual_3) <- paste(unique(landmarks$ID), "_A_ML_3", sep = "")
colnames(A_MorphoData_Manual_3) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
A_MorphoData_ManualMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(A_MorphoData_ManualMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
A_MorphoData_ManualMap$sourcerow <- rep(seq(1,779,1), each=3) 
A_MorphoData_ManualMap$sourcecolumn <- rep(c("A_ml_x3","A_ml_y3", "A_ml_z3"), length = 2337)
A_MorphoData_ManualMap$targetrow <- rep(seq(1,41,1), each = 57)
A_MorphoData_ManualMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(A_MorphoData_ManualMap)){A_MorphoData_Manual_3[A_MorphoData_ManualMap[i,3], A_MorphoData_ManualMap[i,4]] <- landmarks[A_MorphoData_ManualMap[i,1], A_MorphoData_ManualMap[i,2]]
}

rm(i)

A_MorphoData_Manual_3 <- as.matrix(A_MorphoData_Manual_3)
```
####A average
Make empty dataframe to store landmarks
```{r}
A_MorphoData_Manual_avg <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(A_MorphoData_Manual_avg) <- paste(unique(landmarks$ID), "_A_ML_avg", sep = "")
colnames(A_MorphoData_Manual_avg) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
A_MorphoData_ManualMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(A_MorphoData_ManualMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
A_MorphoData_ManualMap$sourcerow <- rep(seq(1,779,1), each=3) 
A_MorphoData_ManualMap$sourcecolumn <- rep(c("A_ml_avgx","A_ml_avgy", "A_ml_avgz"), length = 2337)
A_MorphoData_ManualMap$targetrow <- rep(seq(1,41,1), each = 57)
A_MorphoData_ManualMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(A_MorphoData_ManualMap)){A_MorphoData_Manual_avg[A_MorphoData_ManualMap[i,3], A_MorphoData_ManualMap[i,4]] <- landmarks[A_MorphoData_ManualMap[i,1], A_MorphoData_ManualMap[i,2]]
}

rm(i)

A_MorphoData_Manual_avg <- as.matrix(A_MorphoData_Manual_avg)
```

###B Manual Landmarks
####B Iteration 1
Make empty dataframe to store landmarks
```{r}
B_MorphoData_Manual_1 <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(B_MorphoData_Manual_1) <- paste(unique(landmarks$ID), "_B_ML_1", sep = "")
colnames(B_MorphoData_Manual_1) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
B_MorphoData_ManualMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(B_MorphoData_ManualMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
B_MorphoData_ManualMap$sourcerow <- rep(seq(1,779,1), each=3) 
B_MorphoData_ManualMap$sourcecolumn <- rep(c("B_ml_x1","B_ml_y1", "B_ml_z1"), length = 2337)
B_MorphoData_ManualMap$targetrow <- rep(seq(1,41,1), each = 57)
B_MorphoData_ManualMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(B_MorphoData_ManualMap)){B_MorphoData_Manual_1[B_MorphoData_ManualMap[i,3], B_MorphoData_ManualMap[i,4]] <- landmarks[B_MorphoData_ManualMap[i,1], B_MorphoData_ManualMap[i,2]]
}

rm(i)

B_MorphoData_Manual_1 <- as.matrix(B_MorphoData_Manual_1)
```
####B Iteration 2
Make empty dataframe to store landmarks
```{r}
B_MorphoData_Manual_2 <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(B_MorphoData_Manual_2) <- paste(unique(landmarks$ID), "_B_ML_2", sep = "")
colnames(B_MorphoData_Manual_2) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
B_MorphoData_ManualMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(B_MorphoData_ManualMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
B_MorphoData_ManualMap$sourcerow <- rep(seq(1,779,1), each=3) 
B_MorphoData_ManualMap$sourcecolumn <- rep(c("B_ml_x2","B_ml_y2", "B_ml_z2"), length = 2337)
B_MorphoData_ManualMap$targetrow <- rep(seq(1,41,1), each = 57)
B_MorphoData_ManualMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(B_MorphoData_ManualMap)){B_MorphoData_Manual_2[B_MorphoData_ManualMap[i,3], B_MorphoData_ManualMap[i,4]] <- landmarks[B_MorphoData_ManualMap[i,1], B_MorphoData_ManualMap[i,2]]
}

rm(i)

B_MorphoData_Manual_2 <- as.matrix(B_MorphoData_Manual_2)
```
####B Iteration 3
Make empty dataframe to store landmarks
```{r}
B_MorphoData_Manual_3 <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(B_MorphoData_Manual_3) <- paste(unique(landmarks$ID), "_B_ML_3", sep = "")
colnames(B_MorphoData_Manual_3) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
B_MorphoData_ManualMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(B_MorphoData_ManualMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
B_MorphoData_ManualMap$sourcerow <- rep(seq(1,779,1), each=3) 
B_MorphoData_ManualMap$sourcecolumn <- rep(c("B_ml_x3","B_ml_y3", "B_ml_z3"), length = 2337)
B_MorphoData_ManualMap$targetrow <- rep(seq(1,41,1), each = 57)
B_MorphoData_ManualMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(B_MorphoData_ManualMap)){B_MorphoData_Manual_3[B_MorphoData_ManualMap[i,3], B_MorphoData_ManualMap[i,4]] <- landmarks[B_MorphoData_ManualMap[i,1], B_MorphoData_ManualMap[i,2]]
}

rm(i)

B_MorphoData_Manual_3 <- as.matrix(B_MorphoData_Manual_3)
```
####B average
Make empty dataframe to store landmarks
```{r}
B_MorphoData_Manual_avg <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(B_MorphoData_Manual_avg) <- paste(unique(landmarks$ID), "_B_ML_avg", sep = "")
colnames(B_MorphoData_Manual_avg) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
B_MorphoData_ManualMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(B_MorphoData_ManualMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
B_MorphoData_ManualMap$sourcerow <- rep(seq(1,779,1), each=3) 
B_MorphoData_ManualMap$sourcecolumn <- rep(c("B_ml_avgx","B_ml_avgy", "B_ml_avgz"), length = 2337)
B_MorphoData_ManualMap$targetrow <- rep(seq(1,41,1), each = 57)
B_MorphoData_ManualMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(B_MorphoData_ManualMap)){B_MorphoData_Manual_avg[B_MorphoData_ManualMap[i,3], B_MorphoData_ManualMap[i,4]] <- landmarks[B_MorphoData_ManualMap[i,1], B_MorphoData_ManualMap[i,2]]
}

rm(i)

B_MorphoData_Manual_avg <- as.matrix(B_MorphoData_Manual_avg)
```
###C manual landmarks
Make empty dataframe to store landmarks
```{r}
C_MorphoData_Manual <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(C_MorphoData_Manual) <- paste(unique(landmarks$ID), "_C_ML_avg", sep = "")
colnames(C_MorphoData_Manual) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
C_MorphoData_ManualMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(C_MorphoData_ManualMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
C_MorphoData_ManualMap$sourcerow <- rep(seq(1,779,1), each=3) 
C_MorphoData_ManualMap$sourcecolumn <- rep(c("C_ml_avgx","C_ml_avgy", "C_ml_avgz"), length = 2337)
C_MorphoData_ManualMap$targetrow <- rep(seq(1,41,1), each = 57)
C_MorphoData_ManualMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(C_MorphoData_ManualMap)){C_MorphoData_Manual[C_MorphoData_ManualMap[i,3], C_MorphoData_ManualMap[i,4]] <- landmarks[C_MorphoData_ManualMap[i,1], C_MorphoData_ManualMap[i,2]]
}

rm(i)

C_MorphoData_Manual <- as.matrix(C_MorphoData_Manual)
```

##Convert the automatic landmarks into morpho format
###A Auto
Make empty dataframe to store landmarks
```{r}
A_MorphoData_Auto <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(A_MorphoData_Auto) <- paste(unique(landmarks$ID), "_A_Auto", sep = "")
colnames(A_MorphoData_Auto) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
A_MorphoData_AutoMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(A_MorphoData_AutoMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
A_MorphoData_AutoMap$sourcerow <- rep(seq(1,779,1), each=3) 
A_MorphoData_AutoMap$sourcecolumn <- rep(c("A_loo_x","A_loo_y","A_loo_z"), length = 2337)
A_MorphoData_AutoMap$targetrow <- rep(seq(1,41,1), each = 57)
A_MorphoData_AutoMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(A_MorphoData_AutoMap)){A_MorphoData_Auto[A_MorphoData_AutoMap[i,3], A_MorphoData_AutoMap[i,4]] <- landmarks[A_MorphoData_AutoMap[i,1], A_MorphoData_AutoMap[i,2]]
}

rm(i)

A_MorphoData_Auto <- as.matrix(A_MorphoData_Auto)
```
###B Auto
Make empty dataframe to store landmarks
```{r}
B_MorphoData_Auto <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(B_MorphoData_Auto) <- paste(unique(landmarks$ID), "_B_Auto", sep = "")
colnames(B_MorphoData_Auto) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
B_MorphoData_AutoMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(B_MorphoData_AutoMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
B_MorphoData_AutoMap$sourcerow <- rep(seq(1,779,1), each=3) 
B_MorphoData_AutoMap$sourcecolumn <- rep(c("B_loo_x","B_loo_y","B_loo_z"), length = 2337)
B_MorphoData_AutoMap$targetrow <- rep(seq(1,41,1), each = 57)
B_MorphoData_AutoMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(B_MorphoData_AutoMap)){B_MorphoData_Auto[B_MorphoData_AutoMap[i,3], B_MorphoData_AutoMap[i,4]] <- landmarks[B_MorphoData_AutoMap[i,1], B_MorphoData_AutoMap[i,2]]
}

rm(i)

B_MorphoData_Auto <- as.matrix(B_MorphoData_Auto)
```
###C auto
Make empty dataframe to store landmarks
```{r}
C_MorphoData_Auto <- as.data.frame(matrix(nrow = 41, ncol = 57))
rownames(C_MorphoData_Auto) <- paste(unique(landmarks$ID), "_C_Auto", sep = "")
colnames(C_MorphoData_Auto) <- paste(rep(unique(landmarks$LM.Num), each=3), c("_x", "_y", "_z"), sep="")
```
Make map linking the old dataframe with the new one
```{r}
C_MorphoData_AutoMap <- as.data.frame(matrix(nrow=2337, ncol=4))
colnames(C_MorphoData_AutoMap) <- c('sourcerow', 'sourcecolumn', 'targetrow', 'targetcolumn')
C_MorphoData_AutoMap$sourcerow <- rep(seq(1,779,1), each=3) 
C_MorphoData_AutoMap$sourcecolumn <- rep(c("C_loo_x", "C_loo_y", "C_loo_z"), length = 2337)
C_MorphoData_AutoMap$targetrow <- rep(seq(1,41,1), each = 57)
C_MorphoData_AutoMap$targetcolumn <- rep(seq(1,57,1), length = 2337)
```
Populate the new dataframe
```{r}
for (i in 1:nrow(C_MorphoData_AutoMap)){C_MorphoData_Auto[C_MorphoData_AutoMap[i,3], C_MorphoData_AutoMap[i,4]] <- landmarks[C_MorphoData_AutoMap[i,1], C_MorphoData_AutoMap[i,2]]
}

rm(i)

C_MorphoData_Auto <- as.matrix(C_MorphoData_Auto)
```
#All the manovas
##Manova of manual landmarks only with individual, observer, and iteration as covariates
I would have liked to include camera as a covariate too, but because of the non overlapping samples of camera and individual, we have a non-factorial design, which means that the anova matrices have zero values. Better to talk about how the mesh doesn't care what camera the samples are from, but we can't definitively say that camera is not causing some error. 

Combine manual landmark iteration data together
```{r}
AB_MorphoData_Manual <- rbind(A_MorphoData_Manual_1, A_MorphoData_Manual_2, A_MorphoData_Manual_3, B_MorphoData_Manual_1, B_MorphoData_Manual_2, B_MorphoData_Manual_3)
```
Groups dataframe that has sample information for combined manual landmarking data 
```{r}
AB_Manual_Groups <- as.data.frame(matrix(nrow=nrow(AB_MorphoData_Manual), ncol=4))
colnames(AB_Manual_Groups) <- c("ID", "StudyID", "Observer", "Iteration")
AB_Manual_Groups$ID <- rownames(AB_MorphoData_Manual)
AB_Manual_Groups$StudyID <- as.factor(unique(landmarks$ID))
AB_Manual_Groups$Iteration <- as.factor(c(rep("1", each=41), rep("2", each=41), rep("3", each=41)))
AB_Manual_Groups$Observer <- as.factor(c(rep("A", each=123), rep("B", each=123)))
```
GPA align
```{r}
AB_Morpho_Manual <- arrayspecs(A=AB_MorphoData_Manual, p = 19, k = 3)
AB_Morpho_Manual.gpa <- gpagen(A=AB_Morpho_Manual, print.progress = FALSE)
```
Plot outliers
```{r}
plotOutliers(AB_Morpho_Manual.gpa$coords)
plotAllSpecimens(AB_Morpho_Manual.gpa$coords)
```
No outliers
Make geomorph dataframe 
```{r}
AB_Manual_GDF <- geomorph.data.frame(shape = AB_Morpho_Manual.gpa$coords, individual = AB_Manual_Groups$StudyID, observer = AB_Manual_Groups$Observer, iteration = AB_Manual_Groups$Iteration)

AB_Morpho_Manual.manova <- procD.lm(f1 = shape ~ individual+observer*individual+observer/iteration, data = AB_Manual_GDF, RRPP=TRUE, iter = 999, print.progress=FALSE)
summary(AB_Morpho_Manual.manova)
```
```{r}
plot(AB_Morpho_Manual.manova, type = "diagnostics", outliers = TRUE)
```

##Manova of manual average landmarks with individual and observer as covariates
```{r}
AB_MorphoData_ManualAvg <- rbind(A_MorphoData_Manual_avg, B_MorphoData_Manual_avg)
```
```{r}
AB_ManualAvg_Groups <- as.data.frame(matrix(nrow = nrow(AB_MorphoData_ManualAvg), ncol = 3))
colnames(AB_ManualAvg_Groups) <- c("ID", "StudyID", "Observer")
AB_ManualAvg_Groups$ID <- rownames(AB_MorphoData_ManualAvg)
AB_ManualAvg_Groups$StudyID <- as.factor(unique(landmarks$ID))
AB_ManualAvg_Groups$Observer <- as.factor(c(rep("A", each=41), rep("B", each=41)))
```
```{r}
AB_Morpho_ManualAvg <- arrayspecs(A=AB_MorphoData_ManualAvg, p=19, k=3)
AB_Morpho_ManualAvg.gpa <- gpagen(A=AB_Morpho_ManualAvg, print.progress = FALSE)
```
```{r}
plotOutliers(AB_Morpho_ManualAvg.gpa$coords)
plotAllSpecimens(AB_Morpho_ManualAvg.gpa$coords)
```
```{r}
AB_ManualAvg_GDF <- geomorph.data.frame(shape = AB_Morpho_ManualAvg.gpa$coords, individual = AB_ManualAvg_Groups$StudyID, observer = AB_ManualAvg_Groups$Observer)

AB_Morpho_ManualAvg.manova <- procD.lm(shape~individual+observer, data = AB_ManualAvg_GDF, print.progress = FALSE)
summary(AB_Morpho_ManualAvg.manova)
```
```{r}
plot(AB_Morpho_ManualAvg.manova, type = "diagnostics", outliers = TRUE)
```

##Manova of auto landmarks with individual and observer as covariates.
```{r}
AB_MorphoData_Auto <- rbind(A_MorphoData_Auto, B_MorphoData_Auto)
```
Make groups dataframe containing covariates
```{r}
AB_Auto_Groups <- as.data.frame(matrix(nrow=nrow(AB_MorphoData_Auto), ncol=3))
colnames(AB_Auto_Groups) <- c("ID", "StudyID", "Observer")
AB_Auto_Groups$ID <- rownames(AB_MorphoData_Auto)
AB_Auto_Groups$StudyID <- as.factor(unique(landmarks$ID))
AB_Auto_Groups$Observer <- as.factor(c(rep("A", each=41), rep("B", each=41)))
```
GPA align 
```{r}
AB_Morpho_Auto <- arrayspecs(A=AB_MorphoData_Auto, p=19, k=3)
AB_Morpho_Auto.gpa <- gpagen(A=AB_Morpho_Auto, print.progress = FALSE)
```
Plot outliers
```{r}
plotOutliers(AB_Morpho_Auto.gpa$coords)
plotAllSpecimens(AB_Morpho_Auto.gpa$coords)
```
Make geomorph dataframe and run manova
```{r}
AB_Auto_GDF <- geomorph.data.frame(shape = AB_Morpho_Auto.gpa$coords, individual = AB_Auto_Groups$StudyID, observer=AB_Auto_Groups$Observer)

AB_Morpho_Auto.manova <- procD.lm(shape~individual+observer, data = AB_Auto_GDF, print.progress=FALSE)
summary(AB_Morpho_Auto.manova)
```
```{r}
plot(AB_Morpho_Auto.manova, type = "diagnostics", outliers = TRUE)
```
##Compare manual vs automatic using manova on "C" data, with individual and method as covariates. 
Combine manual and automatic data together
```{r}
C_MorphoData_MLvsAuto <- rbind(C_MorphoData_Manual, C_MorphoData_Auto)
```
Groups dataframe that has sample information for combined manual landmarking data 
```{r}
C_MLvsAuto_Groups <- as.data.frame(matrix(nrow=nrow(C_MorphoData_MLvsAuto), ncol=3))
colnames(C_MLvsAuto_Groups) <- c("ID", "StudyID", "Method")
C_MLvsAuto_Groups$ID <- rownames(C_MorphoData_MLvsAuto)
C_MLvsAuto_Groups$StudyID <- as.factor(unique(landmarks$ID))
C_MLvsAuto_Groups$Method <- as.factor(c(rep("ML", each=41), rep("Auto", each=41)))
```
GPA align manual and automatic landmark iterations. 
```{r}
C_Morpho_MLvsAuto <- arrayspecs(A=C_MorphoData_MLvsAuto, p = 19, k = 3)
C_Morpho_MLvsAuto.gpa <- gpagen(A=C_Morpho_MLvsAuto, print.progress = FALSE)
```
Plot outliers
```{r}
plotOutliers(C_Morpho_MLvsAuto.gpa$coords)
plotAllSpecimens(C_Morpho_MLvsAuto.gpa$coords)
```
Make geomorph dataframe and run manova
```{r}
C_MLvsAuto_GDF <- geomorph.data.frame(shape = C_Morpho_MLvsAuto.gpa$coords, individual = C_MLvsAuto_Groups$StudyID,  method = C_MLvsAuto_Groups$Method)

C_Morpho_MLvsAuto.manova <- procD.lm(shape ~ method+individual, data = C_MLvsAuto_GDF, print.progress=FALSE)
summary(C_Morpho_MLvsAuto.manova)
```
```{r}
plot(C_Morpho_MLvsAuto.manova, type = "diagnostics", outliers = TRUE)
```

##Compare manual vs automatic using manova on A / B trained data with individual, observer, and method as covariates
```{r}
AB_MorphoData_MLvsAuto <- rbind(A_MorphoData_Manual_avg, B_MorphoData_Manual_avg, A_MorphoData_Auto, B_MorphoData_Auto)
```
Groups dataframe that has sample information for combined manual landmarking data 
```{r}
AB_MLvsAuto_Groups <- as.data.frame(matrix(nrow=nrow(AB_MorphoData_MLvsAuto), ncol=4))
colnames(AB_MLvsAuto_Groups) <- c("ID", "StudyID", "Method", "Observer")
AB_MLvsAuto_Groups$ID <- rownames(AB_MorphoData_MLvsAuto)
AB_MLvsAuto_Groups$StudyID <- as.factor(unique(landmarks$ID))
AB_MLvsAuto_Groups$Method <- as.factor(c(rep("ML", each=82), rep("Auto", each=82)))
AB_MLvsAuto_Groups$Observer <- as.factor(c(rep("A", each=41), rep("B", each=41)))
```
GPA align manual and automatic landmark iterations
```{r}
AB_Morpho_MLvsAuto <- arrayspecs(A=AB_MorphoData_MLvsAuto, p = 19, k = 3)
AB_Morpho_MLvsAuto.gpa <- gpagen(A=AB_Morpho_MLvsAuto, print.progress = FALSE)
```
Plot outliers
```{r}
plotOutliers(AB_Morpho_MLvsAuto.gpa$coords)
plotAllSpecimens(AB_Morpho_MLvsAuto.gpa$coords)
```
Make geomorph dataframe 
```{r}
AB_MLvsAuto_GDF <- geomorph.data.frame(shape = AB_Morpho_MLvsAuto.gpa$coords, individual = AB_MLvsAuto_Groups$StudyID, method = AB_MLvsAuto_Groups$Method, observer=AB_MLvsAuto_Groups$Observer)

AB_Morpho_MLvsAuto.manova <- procD.lm(shape~method+individual*observer, data = AB_MLvsAuto_GDF, print.progress = F)
summary(AB_Morpho_MLvsAuto.manova)
```
```{r}
plot(AB_Morpho_MLvsAuto.manova, type = "diagnostic", outliers = TRUE)
```

#Two-block partial least squares
Two-block partial least squares to assess the degree of association between two blocks of Prorustes-aligned coordinates. 
###A manual and automatic data
GPA align manual and automatic landmark iterations separately
```{r}
#Manual
A_Morpho_Manual <- arrayspecs(A=A_MorphoData_Manual_avg, p = 19, k = 3)
#Need to change the names to be matching for the PLS
dimnames(A_Morpho_Manual)[[3]] <- unique(landmarks$ID)
A_Morpho_Manual.gpa <- gpagen(A=A_Morpho_Manual, print.progress = FALSE)
#Automatic
A_Morpho_Auto <- arrayspecs(A=A_MorphoData_Auto, p = 19, k = 3)
#Need to change the names to be matching for the PLS
dimnames(A_Morpho_Auto)[[3]] <- unique(landmarks$ID)
A_Morpho_Auto.gpa <- gpagen(A=A_Morpho_Auto, print.progress = FALSE)
```
Plot outliers in manual data
```{r}
plotOutliers(A_Morpho_Manual.gpa$coords)
```
Plot outliers in automatic data
```{r}
plotOutliers(A_Morpho_Auto.gpa$coords)
```
Run the pls
```{r}
A_PLS <- two.b.pls(A_Morpho_Manual.gpa$coords, A_Morpho_Auto.gpa$coords, iter = 999, seed = NULL, print.progress = FALSE)
summary(A_PLS)
```
Plot the pls
```{r}
plot(A_PLS, warpgrids = FALSE)
```
Variance explained by each one of the PLS PCs.
```{r}
plot(A_PLS$svd$d^2/sum(A_PLS$svd$d^2), type = "b", pch = 16, xlab = "principal components", 
    ylab = "variance explained")
```
Plot first PC scores against each other
```{r}
plot(A_PLS$A1.matrix[,1], A_PLS$A2.matrix[,1])
plot(A_PLS$A1.matrix[,2], A_PLS$A2.matrix[,2])
plot(A_PLS$A1.matrix[,3], A_PLS$A2.matrix[,3])
plot(A_PLS$A1.matrix[,4], A_PLS$A2.matrix[,4])
plot(A_PLS$A1.matrix[,5], A_PLS$A2.matrix[,5])
plot(A_PLS$A1.matrix[,6], A_PLS$A2.matrix[,6])
```
###B
GPA align manual and automatic landmark iterations separately
```{r}
#Manual
B_Morpho_Manual <- arrayspecs(A=B_MorphoData_Manual_avg, p = 19, k = 3)
#Need to change the names to be matching for the PLS
dimnames(B_Morpho_Manual)[[3]] <- unique(landmarks$ID)
B_Morpho_Manual.gpa <- gpagen(A=B_Morpho_Manual, print.progress = FALSE)
#Automatic
B_Morpho_Auto <- arrayspecs(A=B_MorphoData_Auto, p = 19, k = 3)
#Need to change the names to be matching for the PLS
dimnames(B_Morpho_Auto)[[3]] <- unique(landmarks$ID)
B_Morpho_Auto.gpa <- gpagen(A=B_Morpho_Auto, print.progress = FALSE)
```
Plot outliers in manual data
```{r}
plotOutliers(B_Morpho_Manual.gpa$coords)
```
Plot outliers in auto data
```{r}
plotOutliers(B_Morpho_Auto.gpa$coords)
```
Run the pls
```{r}
B_PLS <- two.b.pls(B_Morpho_Manual.gpa$coords, B_Morpho_Auto.gpa$coords, iter = 999, seed = NULL, print.progress = FALSE)
summary(B_PLS)
```
Plot the pls
```{r}
plot(B_PLS, warpgrids = FALSE)
```
Variance explained by each one of the PLS PCs.
```{r}
plot(B_PLS$svd$d^2/sum(B_PLS$svd$d^2), type = "b", pch = 16, xlab = "principal components", 
    ylab = "variance explained")
```
Plot first PC scores against each other
```{r}
plot(B_PLS$A1.matrix[,1], B_PLS$A2.matrix[,1])
plot(B_PLS$A1.matrix[,2], B_PLS$A2.matrix[,2])
plot(B_PLS$A1.matrix[,3], B_PLS$A2.matrix[,3])
plot(B_PLS$A1.matrix[,4], B_PLS$A2.matrix[,4])
plot(B_PLS$A1.matrix[,5], B_PLS$A2.matrix[,5])
plot(B_PLS$A1.matrix[,6], B_PLS$A2.matrix[,6])
```
###C
GPA align manual and automatic landmark iterations separately
```{r}
#Manual
C_Morpho_Manual <- arrayspecs(A=C_MorphoData_Manual, p = 19, k = 3)
#Need to change the names to be matching for the PLS
dimnames(C_Morpho_Manual)[[3]] <- unique(landmarks$ID)
C_Morpho_Manual.gpa <- gpagen(A=C_Morpho_Manual, print.progress = FALSE)
#Automatic
C_Morpho_Auto <- arrayspecs(A=C_MorphoData_Auto, p = 19, k = 3)
#Need to change the names to be matching for the PLS
dimnames(C_Morpho_Auto)[[3]] <- unique(landmarks$ID)
C_Morpho_Auto.gpa <- gpagen(A=C_Morpho_Auto, print.progress = FALSE)
```
Plot outliers in manual data
```{r}
plotOutliers(C_Morpho_Manual.gpa$coords)
```
Plot outliers in automatic data
```{r}
plotOutliers(C_Morpho_Auto.gpa$coords)
```
Run the pls
```{r}
C_PLS <- two.b.pls(C_Morpho_Manual.gpa$coords, C_Morpho_Auto.gpa$coords, iter = 999, seed = NULL, print.progress = FALSE)
summary(C_PLS)
```
Plot the pls
```{r}
plot(C_PLS, warpgrids = FALSE)
```
Variance explained by each one of the PLS PCs.
```{r}
plot(C_PLS$svd$d^2/sum(C_PLS$svd$d^2), type = "b", pch = 16, xlab = "principal components", 
    ylab = "variance explained")
```
Plot first PC scores against each other
```{r}
plot(C_PLS$A1.matrix[,1], C_PLS$A2.matrix[,1])
plot(C_PLS$A1.matrix[,2], C_PLS$A2.matrix[,2])
plot(C_PLS$A1.matrix[,3], C_PLS$A2.matrix[,3])
plot(C_PLS$A1.matrix[,4], C_PLS$A2.matrix[,4])
plot(C_PLS$A1.matrix[,5], C_PLS$A2.matrix[,5])
plot(C_PLS$A1.matrix[,6], C_PLS$A2.matrix[,6])
```

#Centroid size comparison
Extract centroid size from each method
```{r}
CentroidSizes <- as.data.frame(matrix(nrow = length(unique(landmarks$ID)), ncol = 7))
colnames(CentroidSizes) <- c("ID", "A_Manual", "A_Auto", "B_Manual", "B_Auto", "C_Manual", "C_Auto")

CentroidSizes$ID <- unique(landmarks$ID)
CentroidSizes$A_Manual <- A_Morpho_Manual.gpa$Csize
CentroidSizes$A_Auto <- A_Morpho_Auto.gpa$Csize
CentroidSizes$B_Manual <- B_Morpho_Manual.gpa$Csize
CentroidSizes$B_Auto <- B_Morpho_Auto.gpa$Csize
CentroidSizes$C_Manual <- C_Morpho_Manual.gpa$Csize
CentroidSizes$C_Auto <- C_Morpho_Auto.gpa$Csize
```
Compare centroid sizes
```{r}
ggpairs(data=CentroidSizes, columns=c("A_Manual", "A_Auto", "B_Manual", "B_Auto", "C_Manual", "C_Auto"), title="Centroid Size Comparison")
```
ICC for centroid size 
```{r}
ICCmelt <- melt(CentroidSizes[c("ID", "A_Manual", "A_Auto")], id.vars = "ID")
ICC_Centroid_A <- ICCest(x=as.character(ID), y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

ICCmelt <- melt(CentroidSizes[c("ID", "B_Manual", "B_Auto")], id.vars = "ID")
ICC_Centroid_B <- ICCest(x=as.character(ID), y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")

ICCmelt <- melt(CentroidSizes[c("ID", "C_Manual", "C_Auto")], id.vars = "ID")
ICC_Centroid_C <- ICCest(x=as.character(ID), y=value, data=ICCmelt, alpha = 0.05, CI.type = "Smith")
```

###Bland-Altman for centroid sizes
```{r}
ba_centroid_A <- bland.altman.stats(CentroidSizes$A_Auto, CentroidSizes$A_Manual)
ba_centroid_Adf <- as.data.frame(matrix(NA, nrow = 41))
ba_centroid_Adf$means <- ba_centroid_A$means
ba_centroid_Adf$diffs <- ba_centroid_A$diffs

ba_centroid_Aplot <- ggplot(ba_centroid_Adf, aes(x=means, y=diffs))+geom_point(size = 0.5, alpha = 0.5)+ylim(-5,5)+theme_bw()+labs(title = "", x="", y="Differences (mm)")+geom_hline(yintercept = ba_centroid_A$lines['lower.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_centroid_A$lines['mean.diffs'], linetype = "solid", color = "blue")+geom_hline(yintercept = ba_centroid_A$lines['upper.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_centroid_A$CI.lines['lower.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_centroid_A$CI.lines['lower.limit.ci.upper'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_centroid_A$CI.lines['mean.diff.ci.lower'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_centroid_A$CI.lines['mean.diff.ci.upper'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_centroid_A$CI.lines['upper.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_centroid_A$CI.lines['upper.limit.ci.upper'], linetype = "dashed", color = "red")

ba_centroid_B <- bland.altman.stats(CentroidSizes$B_Auto, CentroidSizes$B_Manual)
ba_centroid_Bdf <- as.data.frame(matrix(NA, nrow = 41))
ba_centroid_Bdf$means <- ba_centroid_B$means
ba_centroid_Bdf$diffs <- ba_centroid_B$diffs

ba_centroid_Bplot <- ggplot(ba_centroid_Bdf, aes(x=means, y=diffs))+geom_point(size = 0.5, alpha = 0.5)+ylim(-5,5)+theme_bw()+labs(title = "", x="Means (mm)", y="")+geom_hline(yintercept = ba_centroid_B$lines['lower.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_centroid_B$lines['mean.diffs'], linetype = "solid", color = "blue")+geom_hline(yintercept = ba_centroid_B$lines['upper.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_centroid_B$CI.lines['lower.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_centroid_B$CI.lines['lower.limit.ci.upper'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_centroid_B$CI.lines['mean.diff.ci.lower'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_centroid_B$CI.lines['mean.diff.ci.upper'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_centroid_B$CI.lines['upper.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_centroid_B$CI.lines['upper.limit.ci.upper'], linetype = "dashed", color = "red")

ba_centroid_C <- bland.altman.stats(CentroidSizes$C_Auto, CentroidSizes$C_Manual)
ba_centroid_Cdf <- as.data.frame(matrix(NA, nrow = 41))
ba_centroid_Cdf$means <- ba_centroid_C$means
ba_centroid_Cdf$diffs <- ba_centroid_C$diffs

ba_centroid_Cplot <- ggplot(ba_centroid_Cdf, aes(x=means, y=diffs))+geom_point(size = 0.5, alpha = 0.5)+ylim(-5,5)+theme_bw()+labs(title = "", x="", y="")+geom_hline(yintercept = ba_centroid_C$lines['lower.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_centroid_C$lines['mean.diffs'], linetype = "solid", color = "blue")+geom_hline(yintercept = ba_centroid_C$lines['upper.limit'], linetype = "solid", color = "red")+geom_hline(yintercept = ba_centroid_C$CI.lines['lower.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_centroid_C$CI.lines['lower.limit.ci.upper'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_centroid_C$CI.lines['mean.diff.ci.lower'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_centroid_C$CI.lines['mean.diff.ci.upper'], linetype = "dashed", color = "blue")+geom_hline(yintercept = ba_centroid_C$CI.lines['upper.limit.ci.lower'], linetype = "dashed", color = "red")+geom_hline(yintercept = ba_centroid_C$CI.lines['upper.limit.ci.upper'], linetype = "dashed", color = "red")
```

A few more plots for illustration
```{r}
cs_histogram <- ggplot(data=melt(CentroidSizes, id.vars = c("ID")), aes(x=variable, y=value))+geom_boxplot(outlier.shape = NA)+geom_jitter(width = 0.2, size = 0.8, alpha = 0.5)+labs(x="Measurement method", y="Centroid size (mm)")+theme_bw()+scale_x_discrete(breaks = c("A_Manual", "A_Auto", "B_Manual", "B_Auto", "C_Manual", "C_Auto"), labels = c("A manual", "A auto", "B manual", "B auto", "C manual", "C auto"))

cs_A <- ggplot(CentroidSizes, aes(A_Manual, A_Auto))+geom_point()+theme_bw()+labs(title = "Observer A", subtitle = "ICC = 0.9589", x="", y="Automatic CS (mm)")
cs_B <- ggplot(CentroidSizes, aes(B_Manual, B_Auto))+geom_point()+theme_bw()+labs(title = "Observer B",subtitle = "ICC = 0.9486", x="Manual CS (mm)", y="")
cs_C <- ggplot(CentroidSizes, aes(C_Manual, C_Auto))+geom_point()+theme_bw()+labs(title = "Combined average", subtitle = "ICC = 0.9591", x="", y="")

ggarrange(cs_A, cs_B, cs_C, ba_centroid_Aplot, ba_centroid_Bplot, ba_centroid_Cplot, ncol = 3, nrow=2, labels = c("A", "", "", "B", "", ""))
```

###Histogram of centroid sizes 
```{r}
ggplot(data=melt(CentroidSizes, id.vars = c("ID")), aes(x=variable, y=value))+geom_boxplot(outlier.shape = NA)+geom_jitter(width = 0.2, size = 0.8, alpha = 0.5)+labs(title="Comparison of centroid sizes", x="Measurement method", y="Centroid size (mm)")+theme_bw()+scale_x_discrete(breaks = c("A_Manual", "A_Auto", "B_Manual", "B_Auto", "C_Manual", "C_Auto"), labels = c("A manual", "A auto", "B manual", "B auto", "C manual", "C auto"))
```

###Anova of centroid sizes
Create dataframe with information, without the individual that had a unique camera
```{r}
CentroidSize_Melt <- melt(CentroidSizes, id.vars = c("ID"))
CentroidSize_Melt$ID <- as.factor(CentroidSize_Melt$ID)
CentroidSize_Melt$Observer <- as.factor(c(rep("A", each=82), rep("B", each=82), rep("C", each=82)))
CentroidSize_Melt$Method <- as.factor(c(rep("Manual", each=41), rep("Auto", each=41), rep("Manual", each=41), rep("Auto", each=41), rep("Manual", each=41), rep("Auto", each=41)))

CentroidSize_AOV <- aov(value ~ ID*Observer + Method, data = CentroidSize_Melt)
summary(CentroidSize_AOV)
```
