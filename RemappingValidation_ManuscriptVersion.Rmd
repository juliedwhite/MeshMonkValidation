---
title: "Analysis for MeshMonk Validation"
author: "Julie D. White"
date: "May 26, 2018"
output: html_document
---
#Packages and functions
```{r}
library(readxl)
library(ggplot2)
library(reshape2)
library(plyr)
library(car)
```
Euclidean distance function
```{r}
EuclideanDistance <- function(x1,x2,y1,y2,z1,z2){sqrt(sum((x1-x2)^2+(y1-y2)^2+(z1-z2)^2))}
```
Multiple plot function
```{r}
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

#The dataset
Individuals and their landmarks are rows, then the different landmarkings and statistics in columns. 
```{r}
landmarks <- read_excel("C:/Users/Julie White/Box/MyFiles/MyResearch/RemappingValidation/PeterLandmarks/SparseLandmarkingManualAndAutomaticv20180226LOO.xlsx", sheet = "Combined")
head(landmarks)
```
All the columns with "ml" are the manual landmarks placed by JW and AZ. Three iterations by two raters = six total landmark placements

J_surf_avg landmarks are the result of PC averaging together JW's three iterations and then placing them on the facial surface. J_surf_avg landmarks are the result of PC averaging together AZ's three iterations and then placing them on the facial surface. B_surf_avg landmarks are the result of PC averaging together all six iterations and then placing them on the facial surface.

J_loo landmarks are the result of PC using the J_surf_avg landmarks on all faces to "train" the placement for that landmark and then place them on each face, but for each face he leaves out their landmarks in the training. J_loo landmarks are the result of PC using the J_surf_avg landmarks on all faces to "train" the placement for that landmark and then place them on each face, but for each face he leaves out their landmarks in the training. B_loo landmarks are the result of PC using the B_surf_avg landmarks on all faces to "train" the placement for that landmark and then place them on each face, but for each face he leaves out their landmarks in the training. 

#Intra-observer error of only manual landmarks
Create dataframe for intra observer error of manual landmarks
```{r}
ML_Intra <- landmarks[,c("ID", "LM.Num", "LM.Name")]
```
##Observer AZ
Calculate the sdandard deviations across iterations for x, y, z
```{r}
ML_Intra$A_ml_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_ml_x1", "A_ml_x2", "A_ml_x3")])) 
ML_Intra$A_ml_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_ml_y1", "A_ml_y2", "A_ml_y3")]))
ML_Intra$A_ml_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_ml_z1", "A_ml_z2", "A_ml_z3")]))
```
Average of AZ's sd x, sd y, sd z across all landmarks
```{r}
mean(ML_Intra$A_ml_sdx)
mean(ML_Intra$A_ml_sdy)
mean(ML_Intra$A_ml_sdz)
```
Standard deviation of AZ's sd x, y, and z across all landmarks
```{r}
sd(ML_Intra$A_ml_sdx)
sd(ML_Intra$A_ml_sdy)
sd(ML_Intra$A_ml_sdz)
```

Boxplot of Arslan's sd x, y, z
```{r}
ggplot(data = melt(ML_Intra[, c("ID", "LM.Num", "LM.Name", "A_ml_sdx", "A_ml_sdy", "A_ml_sdz")], id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_minimal()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "right", legend.title = element_blank())+scale_fill_discrete(breaks=c("A_ml_sdx", "A_ml_sdy", "A_ml_sdz"), labels=c("X", "Y", "Z"))+ylab("Standard Deviation (mm)")+xlab("Landmark")+ggtitle("Standard deviation of x, y, and z coordinates for Rater AZ")
```

##Rater JW 
Calculate the sdandard deviations across iterations for x, y, z
```{r}
ML_Intra$J_ml_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("J_ml_x1", "J_ml_x2", "J_ml_x3")])) 
ML_Intra$J_ml_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("J_ml_y1", "J_ml_y2", "J_ml_y3")]))
ML_Intra$J_ml_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("J_ml_z1", "J_ml_z2", "J_ml_z3")]))
```
Average of JW's sd x, y, z across all landmarks
```{r}
mean(ML_Intra$J_ml_sdx)
mean(ML_Intra$J_ml_sdy)
mean(ML_Intra$J_ml_sdz)
```
Standard deviation of JW's sd x, y, and z across all landmarks
```{r}
sd(ML_Intra$J_ml_sdx)
sd(ML_Intra$J_ml_sdy)
sd(ML_Intra$J_ml_sdz)
```
Boxplot of JW's sd x, y, z 
```{r}
ggplot(data = melt(ML_Intra[, c("ID", "LM.Num", "LM.Name", "J_ml_sdx", "J_ml_sdy", "J_ml_sdz")], id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_minimal()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "right", legend.title = element_blank())+scale_fill_discrete(breaks=c("J_ml_sdx", "J_ml_sdy", "J_ml_sdz"), labels=c("X", "Y", "Z"))+ylab("Standard Deviation (mm)")+xlab("Landmark")+ggtitle("Standard deviation of x, y, and z coordinates for Rater JW")
```
##Average per landmark
```{r}
ML_IntraByLandmark <- ddply(ML_Intra,~LM.Name,summarise, A_ml_sdx = mean(A_ml_sdx), A_ml_sdy = mean(A_ml_sdy), A_ml_sdz = mean(A_ml_sdz), J_ml_sdx = mean(J_ml_sdx), J_ml_sdy = mean(J_ml_sdy), J_ml_sdz = mean(J_ml_sdz))

write.table(ML_IntraByLandmark, "ML_IntraByLandmark.txt", row.names = F, col.names = T, quote = F, sep = "\t")

ML_IntraByLandmark
```

#Inter-observer error of only manual landmarks
##Averaged across landmarks and images
```{r}
ML_Inter <- landmarks[,c("ID", "LM.Num", "LM.Name")]
```
This calculation will be performed on the average of each rater's landmarks, since the intra-observer error was low.
Average of AZ's x y and z 
```{r}
landmarks$A_ml_avgx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_x1", "A_ml_x2", "A_ml_x3")])) 
landmarks$A_ml_avgy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_y1", "A_ml_y2", "A_ml_y3")]))
landmarks$A_ml_avgz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_z1", "A_ml_z2", "A_ml_z3")]))
```
Avearge of JW's x y and z 
```{r}
landmarks$J_ml_avgx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("J_ml_x1", "J_ml_x2", "J_ml_x3")])) 
landmarks$J_ml_avgy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("J_ml_y1", "J_ml_y2", "J_ml_y3")]))
landmarks$J_ml_avgz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("J_ml_z1", "J_ml_z2", "J_ml_z3")]))
```
Calculate the standard deviation from AZ's avg x, y, and z values and JW's x, y, and z values.
```{r}
ML_Inter$AJ_ml_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_ml_avgx", "J_ml_avgx")])) 
ML_Inter$AJ_ml_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_ml_avgy", "J_ml_avgy")]))
ML_Inter$AJ_ml_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_ml_avgz", "J_ml_avgz")]))
```
Average of sd x, y, z across all landmarks
```{r}
mean(ML_Inter$AJ_ml_sdx)
mean(ML_Inter$AJ_ml_sdy)
mean(ML_Inter$AJ_ml_sdz)
```
Standard devaiation of sd x, y, z across all landmarks
```{r}
sd(ML_Inter$AJ_ml_sdx)
sd(ML_Inter$AJ_ml_sdy)
sd(ML_Inter$AJ_ml_sdz)
```
Boxplot of sd x, y, z
```{r}
ggplot(data = melt(ML_Inter[, c("ID", "LM.Num", "LM.Name", "AJ_ml_sdx", "AJ_ml_sdy", "AJ_ml_sdz")], id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_minimal()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "right", legend.title = element_blank())+scale_fill_discrete(breaks=c("AJ_ml_sdx", "AJ_ml_sdy", "AJ_ml_sdz"), labels=c("X", "Y", "Z"))+ylab("Standard Deviation (mm)")+xlab("Landmark")+ggtitle("Inter-observer error")
```
One high sdx value for chelion left
```{r}
ML_Inter[which(ML_Inter$AJ_ml_sdx == max(ML_Inter$AJ_ml_sdx)),]
```
 
##Average per landmark 
```{r}
ML_InterByLandmark <- ddply(ML_Inter,~LM.Name,summarise, AJ_ml_sdx = mean(AJ_ml_sdx), AJ_ml_sdy = mean(AJ_ml_sdy), AJ_ml_sdz = mean(AJ_ml_sdz))

write.table(ML_InterByLandmark, "ML_InterByLandmarks.txt", row.names = F, col.names = T, quote = F, sep = "\t")

ML_InterByLandmark
```

#Correlation between manual and automatic landmarks
Create the average of AZ's landmarks as well as JW's landmarks to directly compare to the automatic landmarks. 
```{r}
landmarks$B_ml_avgx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_x1", "A_ml_x2", "A_ml_x3", "J_ml_x1", "J_ml_x2", "J_ml_x3")])) 
landmarks$B_ml_avgy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_y1", "A_ml_y2", "A_ml_y3", "J_ml_y1", "J_ml_y2", "J_ml_y3")]))
landmarks$B_ml_avgz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) mean(x[c("A_ml_z1", "A_ml_z2", "A_ml_z3", "J_ml_z1", "J_ml_z2", "J_ml_z3")]))
```
Correlation between manual landmarks and automatic landmarks
```{r}
cor(landmarks$B_ml_avgx, landmarks$B_loo_x, method = "pearson")
cor(landmarks$B_ml_avgy, landmarks$B_loo_y, method = "pearson")
cor(landmarks$B_ml_avgz, landmarks$B_loo_z, method = "pearson")
```
Plot these correlations
```{r}
multiplot(
  ggplot(landmarks, aes(B_ml_avgx, B_loo_x))+geom_point(size=0.5)+theme_bw()+labs(title = "X", subtitle="r = 0.9995226", x="", y="Automatic landmark coordinates"),
  ggplot(landmarks, aes(B_ml_avgy, B_loo_y))+geom_point(size=0.5)+theme_bw()+labs(title = "Y", subtitle="r = 0.9997573", x="Manual landmark coordinates", y=NULL),
  ggplot(landmarks, aes(B_ml_avgz, B_loo_z))+geom_point(size=0.5)+theme_bw()+labs(title = "Z", subtitle="r = 0.9999215", x="", y=NULL), cols = 3)
```

#Standard deviation between avg of manual landmarks and auto landmarks trained using average of all manual landmarks
Create a dataframe to store the results of the comparisons
```{r}
MLvsAuto <- landmarks[,c("ID", "LM.Num", "LM.Name")]
```
Standard deviation between the ML landmarks and the automatic landmarks.
```{r}
MLvsAuto$B_ml_loo_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c('B_ml_avgx', 'B_loo_x')]))
MLvsAuto$B_ml_loo_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c('B_ml_avgy', 'B_loo_y')]))
MLvsAuto$B_ml_loo_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c('B_ml_avgz', 'B_loo_z')]))
```
Average of sd x, y, z across all landmarks
```{r}
mean(MLvsAuto$B_ml_loo_sdx)
mean(MLvsAuto$B_ml_loo_sdy)
mean(MLvsAuto$B_ml_loo_sdz)
```
Avearge x, y, and z values together to get a per-image estimate
```{r}
MLvsAuto$B_ml_loo_avg_sd <- rowMeans(subset(MLvsAuto, select=c(B_ml_loo_sdx, B_ml_loo_sdy, B_ml_loo_sdz)))
```
Average per landmark. 
```{r}
MLvsAuto_SDPerLMK <- ddply(.data = MLvsAuto, ~ LM.Name , summarize, B_ml_loo_sdx = mean(B_ml_loo_sdx), B_ml_loo_sdy = mean(B_ml_loo_sdy), B_ml_loo_sdz = mean(B_ml_loo_sdz), B_ml_loo_avg_sd = mean(B_ml_loo_avg_sd))

write.table(MLvsAuto_SDPerLMK, "MLvsAuto_SDPerLMK.txt", row.names = F, col.names = T, quote = F, sep = "\t")

MLvsAuto_SDPerLMK
```
Boxplot of sd x, y, z
```{r}
ggplot(data = MLvsAuto, aes(x=LM.Name, y=B_ml_loo_avg_sd))+geom_boxplot()+theme_bw()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "none")+ylab("Standard Deviation (mm)")+xlab("Landmark")+ggtitle("Standard deviation between manual and automatic landmarks")
```

#Comparison of inter-observer error calculated with manual data vs. inter-observer error calculated with automatic data
Create dataframe to store the results
```{r}
Auto_Inter <- landmarks[,c("ID", "LM.Num", "LM.Name")]
```
Calculate standard deviation between automatic landmarks trained using AZ and JW's manual landmarks
```{r}
Auto_Inter$AJ_auto_sdx <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_loo_x", "J_loo_x")]))
Auto_Inter$AJ_auto_sdy <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_loo_y", "J_loo_y")]))
Auto_Inter$AJ_auto_sdz <- apply(landmarks[4:ncol(landmarks)], 1, function(x) sd(x[c("A_loo_z", "J_loo_z")]))
```
Merge the manual landmark inter-observer error with the automatic landmark interobserver error
```{r}
Inter_MLvsAuto <- merge(ML_Inter, Auto_Inter[,c("ID","LM.Num","LM.Name","AJ_auto_sdx", "AJ_auto_sdy", "AJ_auto_sdz")],by = c("ID", "LM.Num", "LM.Name"))
```
Calculate average of the manual landmark inter-observer error (across x, y, z) and average of auto inter-observer error (across x, y, and z)
```{r}
Inter_MLvsAuto$AJ_ml_avg_sd <- rowMeans(subset(Inter_MLvsAuto, select = c(AJ_ml_sdx, AJ_ml_sdy, AJ_ml_sdz)))
Inter_MLvsAuto$AJ_auto_avg_sd <- rowMeans(subset(Inter_MLvsAuto, select = c(AJ_auto_sdx, AJ_auto_sdy, AJ_auto_sdz)))
```
Average per landmark. 
```{r}
Inter_MLvsAuto_PerLMK <- ddply(.data = Inter_MLvsAuto, ~ LM.Name , summarize, AJ_ml_sdx = mean(AJ_ml_sdx), AJ_ml_sdy = mean(AJ_ml_sdy), AJ_ml_sdz = mean(AJ_ml_sdz), AJ_ml_avg_sd = mean(AJ_ml_avg_sd), AJ_auto_sdx = mean(AJ_auto_sdx), AJ_auto_sdy = mean(AJ_auto_sdy), AJ_auto_sdz = mean(AJ_auto_sdz), AJ_auto_avg_sd = mean(AJ_auto_avg_sd))

Inter_MLvsAuto_PerLMK
```
Graph per X, y, and z and per landmark
```{r}
ggplot(data = melt(Inter_MLvsAuto[, c("ID", "LM.Num", "LM.Name", "AJ_ml_avg_sd", "AJ_auto_avg_sd")], id.vars = c("ID", "LM.Num", "LM.Name")), aes(x=LM.Name, y=value, fill=variable))+geom_boxplot()+theme_minimal()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.1), legend.position = "top", legend.title = element_blank())+scale_fill_discrete(breaks=c("AJ_ml_avg_sd", "AJ_auto_avg_sd"), labels=c("Manual", "Automatic"))+ylab("Standard Deviation (mm)")+xlab("Landmark")+ggtitle("Comparison of inter-observer errors\ncalculated using manual vs. automatic landmarks")
```

See if this difference is significant using Levene's test
Make a dataframe to store the results
```{r}
Inter_MLvsAuto_Levene <- as.data.frame(Inter_MLvsAuto_PerLMK[,c("LM.Name")])
colnames(Inter_MLvsAuto_Levene) <- "LM.Name"
Inter_MLvsAuto_Levene$X_Fvalue <- 0
Inter_MLvsAuto_Levene$X_pvalue <- 0
Inter_MLvsAuto_Levene$Y_Fvalue <- 0
Inter_MLvsAuto_Levene$Y_pvalue <- 0
Inter_MLvsAuto_Levene$Z_Fvalue <- 0
Inter_MLvsAuto_Levene$Z_pvalue <- 0
Inter_MLvsAuto_Levene$Mean_Fvalue <- 0
Inter_MLvsAuto_Levene$Mean_pvalue <- 0
```
Calculate Levene's test for each landmark and each comparison. 
```{r}
#X values
for (i in seq(1,19,1)){
  levene_tmp <- leveneTest(value~variable, data=melt(Inter_MLvsAuto[which(Inter_MLvsAuto$LM.Name == landmarklist[i]), c("AJ_ml_sdx", "AJ_auto_sdx")]))
  Inter_MLvsAuto_Levene[i,2] <- levene_tmp[1,2] 
  Inter_MLvsAuto_Levene[i,3] <- levene_tmp[1,3]
}

#Y values
for (i in seq(1,19,1)){
  levene_tmp <- leveneTest(value~variable, data=melt(Inter_MLvsAuto[which(Inter_MLvsAuto$LM.Name == landmarklist[i]), c("AJ_ml_sdy", "AJ_auto_sdy")]))
  Inter_MLvsAuto_Levene[i,4] <- levene_tmp[1,2] 
  Inter_MLvsAuto_Levene[i,5] <- levene_tmp[1,3]
}

#Z values
for (i in seq(1,19,1)){
  levene_tmp <- leveneTest(value~variable, data=melt(Inter_MLvsAuto[which(Inter_MLvsAuto$LM.Name == landmarklist[i]), c("AJ_ml_sdz", "AJ_auto_sdz")]))
  Inter_MLvsAuto_Levene[i,6] <- levene_tmp[1,2] 
  Inter_MLvsAuto_Levene[i,7] <- levene_tmp[1,3]
}

#Mean values
for (i in seq(1,19,1)){
  levene_tmp <- leveneTest(value~variable, data=melt(Inter_MLvsAuto[which(Inter_MLvsAuto$LM.Name == landmarklist[i]), c("AJ_ml_avg_sd", "AJ_auto_avg_sd")]))
  Inter_MLvsAuto_Levene[i,8] <- levene_tmp[1,2] 
  Inter_MLvsAuto_Levene[i,9] <- levene_tmp[1,3]
}
```
Merge with means per landmark
```{r}
Inter_MLvsAuto_PerLMK <- merge(Inter_MLvsAuto_PerLMK, Inter_MLvsAuto_Levene, by = "LM.Name")

write.table(Inter_MLvsAuto_PerLMK, "Inter_MLvsAuto_PerLMK.txt", row.names = F, col.names = T, quote = F, sep = "\t")

Inter_MLvsAuto_PerLMK
```



